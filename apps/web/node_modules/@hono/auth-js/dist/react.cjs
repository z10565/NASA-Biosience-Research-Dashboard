"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/react.tsx
var react_exports = {};
__export(react_exports, {
  SessionContext: () => SessionContext,
  SessionProvider: () => SessionProvider,
  authConfigManager: () => authConfigManager,
  getCsrfToken: () => getCsrfToken,
  getProviders: () => getProviders,
  getSession: () => getSession,
  signIn: () => signIn,
  signOut: () => signOut,
  useOauthPopupLogin: () => useOauthPopupLogin,
  useSession: () => useSession
});
module.exports = __toCommonJS(react_exports);
var React = __toESM(require("react"), 1);
var import_react2 = require("react");

// src/client.ts
var import_errors = require("@auth/core/errors");
var import_react = require("react");
var ClientFetchError = class extends import_errors.AuthError {
};
var ClientSessionError = class extends import_errors.AuthError {
};
async function fetchData(path, config, logger2, req = {}) {
  const url = `${config.baseUrl}${config.basePath}/${path}`;
  try {
    const options = {
      headers: {
        "Content-Type": "application/json",
        ...req?.headers?.cookie ? { cookie: req.headers.cookie } : {}
      },
      credentials: config.credentials
    };
    if (req?.body) {
      options.body = JSON.stringify(req.body);
      options.method = "POST";
    }
    const res = await fetch(url, options);
    const data = await res.json();
    if (!res.ok) {
      throw data;
    }
    return data;
  } catch (error) {
    logger2.error(new ClientFetchError(error.message, error));
    return null;
  }
}
function useOnline() {
  const [isOnline, setIsOnline] = (0, import_react.useState)(
    typeof navigator !== "undefined" ? navigator.onLine : false
  );
  (0, import_react.useEffect)(() => {
    const abortController = new AbortController();
    const { signal } = abortController;
    const setOnline = () => {
      setIsOnline(true);
    };
    const setOffline = () => {
      setIsOnline(false);
    };
    window.addEventListener("online", setOnline, { signal });
    window.addEventListener("offline", setOffline, { signal });
    return () => {
      abortController.abort();
    };
  }, []);
  return isOnline;
}
function now() {
  return Math.floor(Date.now() / 1e3);
}
function parseUrl(url) {
  const defaultUrl = "http://localhost:3000/api/auth";
  const parsedUrl = new URL(url ? url.startsWith("http") ? url : `https://${url}` : defaultUrl);
  const path = parsedUrl.pathname === "/" ? "/api/auth" : parsedUrl.pathname.replace(/\/$/, "");
  const base = `${parsedUrl.origin}${path}`;
  return {
    origin: parsedUrl.origin,
    host: parsedUrl.host,
    path,
    base,
    toString: () => base
  };
}

// src/react.tsx
var logger = {
  debug: console.debug,
  error: console.error,
  warn: console.warn
};
var AuthConfigManager = class _AuthConfigManager {
  static instance = null;
  config;
  constructor() {
    this.config = this.createDefaultConfig();
  }
  createDefaultConfig() {
    return {
      baseUrl: typeof window !== "undefined" ? parseUrl(window.location.origin).origin : "",
      basePath: typeof window !== "undefined" ? parseUrl(window.location.origin).path : "/api/auth",
      credentials: "same-origin",
      lastSync: 0,
      session: null,
      fetchSession: async () => void 0
    };
  }
  static getInstance() {
    if (!_AuthConfigManager.instance) {
      _AuthConfigManager.instance = new _AuthConfigManager();
    }
    return _AuthConfigManager.instance;
  }
  setConfig(userConfig) {
    this.config = { ...this.config, ...userConfig };
  }
  getConfig() {
    return this.config;
  }
  initializeConfig(hasInitialSession) {
    this.config.lastSync = hasInitialSession ? now() : 0;
  }
};
var authConfigManager = AuthConfigManager.getInstance();
var SessionContext = React.createContext(void 0);
function useInitializeSession(hasInitialSession, initialSession) {
  const authConfig = authConfigManager.getConfig();
  const [session, setSession] = React.useState(initialSession);
  const [loading, setLoading] = React.useState(!hasInitialSession);
  (0, import_react2.useEffect)(() => {
    authConfig.fetchSession = async ({ event } = {}) => {
      try {
        const isStorageEvent = event === "storage";
        if (isStorageEvent || !authConfig.session) {
          authConfig.lastSync = now();
          authConfig.session = await getSession();
          setSession(authConfig.session);
          return;
        }
        if (!event || !authConfig.session || now() < authConfig.lastSync) {
          return;
        }
        authConfig.lastSync = now();
        authConfig.session = await getSession();
        setSession(authConfig.session);
      } catch (error) {
        logger.error(new ClientSessionError(error.message, error));
      } finally {
        setLoading(false);
      }
    };
    authConfig.fetchSession();
    return () => {
      authConfig.lastSync = 0;
      authConfig.session = null;
      authConfig.fetchSession = async () => void 0;
    };
  }, []);
  return { session, setSession, loading, setLoading };
}
function useVisibilityChangeEventListener(authConfig, refetchOnWindowFocus) {
  (0, import_react2.useEffect)(() => {
    const abortController = new AbortController();
    const handleVisibilityChange = () => {
      if (refetchOnWindowFocus && document.visibilityState === "visible") {
        authConfig.fetchSession({ event: "visibilitychange" });
      }
    };
    document.addEventListener("visibilitychange", handleVisibilityChange, {
      signal: abortController.signal
    });
    return () => {
      abortController.abort();
    };
  }, [refetchOnWindowFocus]);
}
function useRefetchInterval(authConfig, refetchInterval, shouldRefetch) {
  (0, import_react2.useEffect)(() => {
    if (refetchInterval && shouldRefetch) {
      const intervalId = setInterval(() => {
        if (authConfig.session) {
          authConfig.fetchSession({ event: "poll" });
        }
      }, refetchInterval * 1e3);
      return () => {
        clearInterval(intervalId);
      };
    }
  }, [refetchInterval, shouldRefetch]);
}
async function getSession(params) {
  const { baseUrl, basePath, credentials } = authConfigManager.getConfig();
  const session = await fetchData(
    "session",
    {
      baseUrl,
      basePath,
      credentials
    },
    logger,
    params
  );
  return session;
}
async function getCsrfToken() {
  const { baseUrl, basePath, credentials } = authConfigManager.getConfig();
  const response = await fetchData(
    "csrf",
    {
      baseUrl,
      basePath,
      credentials
    },
    logger
  );
  return response?.csrfToken ?? "";
}
function SessionProvider(props) {
  if (!SessionContext) {
    throw new Error("React Context is unavailable in Server Components");
  }
  const { children, refetchInterval, refetchWhenOffline = true } = props;
  const authConfig = authConfigManager.getConfig();
  const hasInitialSession = !!props.session;
  authConfigManager.initializeConfig(hasInitialSession);
  const { session, setSession, loading, setLoading } = useInitializeSession(
    hasInitialSession,
    props.session ?? null
  );
  useVisibilityChangeEventListener(authConfig, props.refetchOnWindowFocus ?? true);
  const isOnline = useOnline();
  const shouldRefetch = refetchWhenOffline || isOnline;
  useRefetchInterval(authConfig, refetchInterval, shouldRefetch);
  const contextValue = (0, import_react2.useMemo)(
    () => ({
      data: session,
      status: loading ? "loading" : session ? "authenticated" : "unauthenticated",
      update: async (data) => {
        if (loading || !session) {
          return;
        }
        setLoading(true);
        const updatedSession = await fetchData(
          "session",
          authConfig,
          logger,
          data ? { body: { csrfToken: await getCsrfToken(), data } } : void 0
        );
        setLoading(false);
        if (updatedSession) {
          setSession(updatedSession);
        }
        return updatedSession;
      }
    }),
    [session, loading, setSession]
  );
  return /* @__PURE__ */ React.createElement(SessionContext.Provider, { value: contextValue }, children);
}
function useSession(options) {
  if (!SessionContext) {
    throw new Error("React Context is unavailable in Server Components");
  }
  const config = authConfigManager.getConfig();
  const session = (0, import_react2.useContext)(SessionContext);
  const { required, onUnauthenticated } = options ?? {};
  const requiredAndNotLoading = required && session?.status === "unauthenticated";
  (0, import_react2.useEffect)(() => {
    if (requiredAndNotLoading) {
      const url = `${config.baseUrl}${config.basePath}/signin?${new URLSearchParams({
        error: "SessionRequired",
        callbackUrl: window.location.href
      })}`;
      if (onUnauthenticated) {
        onUnauthenticated();
      } else {
        window.location.href = url;
      }
    }
  }, [requiredAndNotLoading, onUnauthenticated]);
  if (requiredAndNotLoading) {
    return {
      data: session?.data,
      update: session?.update,
      status: "loading"
    };
  }
  return session;
}
async function getProviders() {
  return fetchData("providers", authConfigManager.getConfig(), logger);
}
async function signIn(provider, options = {}, authorizationParams = {}) {
  const { callbackUrl = window.location.href, redirect = true, ...opts } = options;
  const config = authConfigManager.getConfig();
  const href = `${config.baseUrl}${config.basePath}`;
  const providers = await getProviders();
  if (!providers) {
    window.location.href = `${href}/error`;
    return;
  }
  if (!provider || !(provider in providers)) {
    window.location.href = `${href}/signin?${new URLSearchParams({ callbackUrl })}`;
    return;
  }
  const isCredentials = providers[provider].type === "credentials";
  const isEmail = providers[provider].type === "email";
  const signInUrl = `${href}/${isCredentials ? "callback" : "signin"}/${provider}`;
  const csrfToken = await getCsrfToken();
  const res = await fetch(`${signInUrl}?${new URLSearchParams(authorizationParams)}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "X-Auth-Return-Redirect": "1"
    },
    body: new URLSearchParams({ ...opts, csrfToken, callbackUrl }),
    credentials: config.credentials
  });
  const data = await res.json();
  if (redirect) {
    const url = data.url ?? callbackUrl;
    window.location.href = url;
    if (url.includes("#")) {
      window.location.reload();
    }
    return;
  }
  const error = new URL(data.url).searchParams.get("error");
  if (res.ok) {
    await config.fetchSession?.({ event: "storage" });
  }
  return {
    error,
    status: res.status,
    ok: res.ok,
    url: error ? null : data.url
  };
}
async function signOut(options) {
  const { callbackUrl = window.location.href, redirect = true } = options ?? {};
  const config = authConfigManager.getConfig();
  const csrfToken = await getCsrfToken();
  const res = await fetch(`${config.baseUrl}${config.basePath}/signout`, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "X-Auth-Return-Redirect": "1"
    },
    body: new URLSearchParams({ csrfToken, callbackUrl }),
    credentials: config.credentials
  });
  const data = await res.json();
  if (redirect) {
    const url = data.url ?? callbackUrl;
    window.location.href = url;
    if (url.includes("#")) {
      window.location.reload();
    }
    return void 0;
  }
  await config.fetchSession?.({ event: "storage" });
  return data;
}
var createPopup = ({ url, title, height, width }) => {
  const left = window.screenX + (window.outerWidth - width) / 2;
  const top = window.screenY + (window.outerHeight - height) / 2.5;
  const externalPopup = window.open(
    url,
    title,
    `width=${width},height=${height},left=${left},top=${top}`
  );
  return externalPopup;
};
var useOauthPopupLogin = (provider, options = {}) => {
  const { width = 500, height = 500, title = "Signin", onSuccess, callbackUrl = "/" } = options;
  const [externalWindow, setExternalWindow] = (0, import_react2.useState)();
  const [state, setState] = (0, import_react2.useState)({ status: "loading" });
  const popUpSignin = (0, import_react2.useCallback)(async () => {
    const res = await signIn(provider, {
      redirect: false,
      callbackUrl
    });
    if (res?.error) {
      setState({ status: "errored", error: res.error });
      return;
    }
    setExternalWindow(
      createPopup({
        url: res?.url,
        title,
        width,
        height
      })
    );
  }, []);
  (0, import_react2.useEffect)(() => {
    const handleMessage = (event) => {
      if (event.origin !== window.location.origin) {
        return;
      }
      if (event.data.status) {
        setState(event.data);
        if (event.data.status === "success") {
          onSuccess?.();
        }
        externalWindow?.close();
      }
    };
    window.addEventListener("message", handleMessage);
    return () => {
      window.removeEventListener("message", handleMessage);
      externalWindow?.close();
    };
  }, [externalWindow]);
  return { popUpSignin, ...state };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SessionContext,
  SessionProvider,
  authConfigManager,
  getCsrfToken,
  getProviders,
  getSession,
  signIn,
  signOut,
  useOauthPopupLogin,
  useSession
});
