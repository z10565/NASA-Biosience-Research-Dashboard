import { BuiltInProviderType, ProviderType, RedirectableProviderType } from '@auth/core/providers';
import { Session } from '@auth/core/types';
import * as React$1 from 'react';

interface GetSessionParams {
    event?: 'storage' | 'timer' | 'hidden' | string;
    triggerEvent?: boolean;
}
interface AuthClientConfig {
    baseUrl: string;
    basePath: string;
    credentials: RequestCredentials;
    lastSync: number;
    session: Session | null;
    fetchSession: (params?: GetSessionParams) => Promise<void>;
}
interface UseSessionOptions<R extends boolean> {
    required: R;
    onUnauthenticated?: () => void;
}
type LiteralUnion<T extends U, U = string> = T | (U & Record<never, never>);
interface ClientSafeProvider {
    id: LiteralUnion<BuiltInProviderType>;
    name: string;
    type: ProviderType;
    signinUrl: string;
    callbackUrl: string;
}
interface SignInOptions extends Record<string, unknown> {
    callbackUrl?: string;
    redirect?: boolean;
}
interface SignInResponse {
    error: string | undefined;
    status: number;
    ok: boolean;
    url: string | null;
}
type SignInAuthorizationParams = string | string[][] | Record<string, string> | URLSearchParams;
interface SignOutResponse {
    url: string;
}
interface SignOutParams<R extends boolean = true> {
    callbackUrl?: string;
    redirect?: R;
}
interface SessionProviderProps {
    children: React.ReactNode;
    session?: Session | null;
    refetchInterval?: number;
    refetchOnWindowFocus?: boolean;
    refetchWhenOffline?: false;
}
type UpdateSession = (data?: any) => Promise<Session | null>;
type SessionContextValue<R extends boolean = false> = R extends true ? {
    update: UpdateSession;
    data: Session;
    status: 'authenticated';
} | {
    update: UpdateSession;
    data: null;
    status: 'loading';
} : {
    update: UpdateSession;
    data: Session;
    status: 'authenticated';
} | {
    update: UpdateSession;
    data: null;
    status: 'unauthenticated' | 'loading';
};
type WindowProps = {
    url: string;
    title: string;
    width: number;
    height: number;
};
type AuthState = {
    status: 'loading' | 'success' | 'errored';
    error?: string;
};

declare class AuthConfigManager {
    private static instance;
    private config;
    private constructor();
    private createDefaultConfig;
    static getInstance(): AuthConfigManager;
    setConfig(userConfig: Partial<AuthClientConfig>): void;
    getConfig(): AuthClientConfig;
    initializeConfig(hasInitialSession: boolean): void;
}
declare const authConfigManager: AuthConfigManager;
declare const SessionContext: React$1.Context<SessionContextValue | undefined>;
declare function getSession(params?: GetSessionParams): Promise<Session | null>;
declare function getCsrfToken(): Promise<string>;
declare function SessionProvider(props: SessionProviderProps): React$1.JSX.Element;
declare function useSession<R extends boolean>(options?: UseSessionOptions<R>): SessionContextValue<R>;
type ProvidersType = Record<LiteralUnion<BuiltInProviderType>, ClientSafeProvider>;
declare function getProviders(): Promise<ProvidersType | null>;
declare function signIn<P extends RedirectableProviderType | undefined = undefined>(provider?: LiteralUnion<P extends RedirectableProviderType ? P | BuiltInProviderType : BuiltInProviderType>, options?: SignInOptions, authorizationParams?: SignInAuthorizationParams): Promise<P extends RedirectableProviderType ? SignInResponse | undefined : undefined>;
declare function signOut<R extends boolean = true>(options?: SignOutParams<R>): Promise<R extends true ? undefined : SignOutResponse>;
interface PopupLoginOptions extends Partial<Omit<WindowProps, 'url'>> {
    onSuccess?: () => void;
    callbackUrl?: string;
}
interface LoginState extends AuthState {
    popUpSignin: () => Promise<void>;
}
declare const useOauthPopupLogin: (provider: Parameters<typeof signIn>[0], options?: PopupLoginOptions) => LoginState;

export { SessionContext, SessionProvider, authConfigManager, getCsrfToken, getProviders, getSession, signIn, signOut, useOauthPopupLogin, useSession };
