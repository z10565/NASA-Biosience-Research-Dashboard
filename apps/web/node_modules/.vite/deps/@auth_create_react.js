import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __publicField,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@hono/auth-js/dist/react.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
import { AuthError } from "@auth/core/errors";
var ClientFetchError = class extends AuthError {
};
var ClientSessionError = class extends AuthError {
};
async function fetchData(path, config, logger2, req = {}) {
  var _a2;
  const url = `${config.baseUrl}${config.basePath}/${path}`;
  try {
    const options = {
      headers: {
        "Content-Type": "application/json",
        ...((_a2 = req == null ? void 0 : req.headers) == null ? void 0 : _a2.cookie) ? { cookie: req.headers.cookie } : {}
      },
      credentials: config.credentials
    };
    if (req == null ? void 0 : req.body) {
      options.body = JSON.stringify(req.body);
      options.method = "POST";
    }
    const res = await fetch(url, options);
    const data = await res.json();
    if (!res.ok) {
      throw data;
    }
    return data;
  } catch (error) {
    logger2.error(new ClientFetchError(error.message, error));
    return null;
  }
}
function useOnline() {
  const [isOnline, setIsOnline] = (0, import_react2.useState)(
    typeof navigator !== "undefined" ? navigator.onLine : false
  );
  (0, import_react2.useEffect)(() => {
    const abortController = new AbortController();
    const { signal } = abortController;
    const setOnline = () => {
      setIsOnline(true);
    };
    const setOffline = () => {
      setIsOnline(false);
    };
    window.addEventListener("online", setOnline, { signal });
    window.addEventListener("offline", setOffline, { signal });
    return () => {
      abortController.abort();
    };
  }, []);
  return isOnline;
}
function now() {
  return Math.floor(Date.now() / 1e3);
}
function parseUrl(url) {
  const defaultUrl = "http://localhost:3000/api/auth";
  const parsedUrl = new URL(url ? url.startsWith("http") ? url : `https://${url}` : defaultUrl);
  const path = parsedUrl.pathname === "/" ? "/api/auth" : parsedUrl.pathname.replace(/\/$/, "");
  const base = `${parsedUrl.origin}${path}`;
  return {
    origin: parsedUrl.origin,
    host: parsedUrl.host,
    path,
    base,
    toString: () => base
  };
}
var logger = {
  debug: console.debug,
  error: console.error,
  warn: console.warn
};
var _a;
var AuthConfigManager = (_a = class {
  constructor() {
    __publicField(this, "config");
    this.config = this.createDefaultConfig();
  }
  createDefaultConfig() {
    return {
      baseUrl: typeof window !== "undefined" ? parseUrl(window.location.origin).origin : "",
      basePath: typeof window !== "undefined" ? parseUrl(window.location.origin).path : "/api/auth",
      credentials: "same-origin",
      lastSync: 0,
      session: null,
      fetchSession: async () => void 0
    };
  }
  static getInstance() {
    if (!_a.instance) {
      _a.instance = new _a();
    }
    return _a.instance;
  }
  setConfig(userConfig) {
    this.config = { ...this.config, ...userConfig };
  }
  getConfig() {
    return this.config;
  }
  initializeConfig(hasInitialSession) {
    this.config.lastSync = hasInitialSession ? now() : 0;
  }
}, __publicField(_a, "instance", null), _a);
var authConfigManager = AuthConfigManager.getInstance();
var SessionContext = React.createContext(void 0);
function useInitializeSession(hasInitialSession, initialSession) {
  const authConfig = authConfigManager.getConfig();
  const [session, setSession] = React.useState(initialSession);
  const [loading, setLoading] = React.useState(!hasInitialSession);
  (0, import_react.useEffect)(() => {
    authConfig.fetchSession = async ({ event } = {}) => {
      try {
        const isStorageEvent = event === "storage";
        if (isStorageEvent || !authConfig.session) {
          authConfig.lastSync = now();
          authConfig.session = await getSession();
          setSession(authConfig.session);
          return;
        }
        if (!event || !authConfig.session || now() < authConfig.lastSync) {
          return;
        }
        authConfig.lastSync = now();
        authConfig.session = await getSession();
        setSession(authConfig.session);
      } catch (error) {
        logger.error(new ClientSessionError(error.message, error));
      } finally {
        setLoading(false);
      }
    };
    authConfig.fetchSession();
    return () => {
      authConfig.lastSync = 0;
      authConfig.session = null;
      authConfig.fetchSession = async () => void 0;
    };
  }, []);
  return { session, setSession, loading, setLoading };
}
function useVisibilityChangeEventListener(authConfig, refetchOnWindowFocus) {
  (0, import_react.useEffect)(() => {
    const abortController = new AbortController();
    const handleVisibilityChange = () => {
      if (refetchOnWindowFocus && document.visibilityState === "visible") {
        authConfig.fetchSession({ event: "visibilitychange" });
      }
    };
    document.addEventListener("visibilitychange", handleVisibilityChange, {
      signal: abortController.signal
    });
    return () => {
      abortController.abort();
    };
  }, [refetchOnWindowFocus]);
}
function useRefetchInterval(authConfig, refetchInterval, shouldRefetch) {
  (0, import_react.useEffect)(() => {
    if (refetchInterval && shouldRefetch) {
      const intervalId = setInterval(() => {
        if (authConfig.session) {
          authConfig.fetchSession({ event: "poll" });
        }
      }, refetchInterval * 1e3);
      return () => {
        clearInterval(intervalId);
      };
    }
  }, [refetchInterval, shouldRefetch]);
}
async function getSession(params) {
  const { baseUrl, basePath, credentials } = authConfigManager.getConfig();
  const session = await fetchData(
    "session",
    {
      baseUrl,
      basePath,
      credentials
    },
    logger,
    params
  );
  return session;
}
async function getCsrfToken() {
  const { baseUrl, basePath, credentials } = authConfigManager.getConfig();
  const response = await fetchData(
    "csrf",
    {
      baseUrl,
      basePath,
      credentials
    },
    logger
  );
  return (response == null ? void 0 : response.csrfToken) ?? "";
}
function SessionProvider(props) {
  if (!SessionContext) {
    throw new Error("React Context is unavailable in Server Components");
  }
  const { children, refetchInterval, refetchWhenOffline = true } = props;
  const authConfig = authConfigManager.getConfig();
  const hasInitialSession = !!props.session;
  authConfigManager.initializeConfig(hasInitialSession);
  const { session, setSession, loading, setLoading } = useInitializeSession(
    hasInitialSession,
    props.session ?? null
  );
  useVisibilityChangeEventListener(authConfig, props.refetchOnWindowFocus ?? true);
  const isOnline = useOnline();
  const shouldRefetch = refetchWhenOffline || isOnline;
  useRefetchInterval(authConfig, refetchInterval, shouldRefetch);
  const contextValue = (0, import_react.useMemo)(
    () => ({
      data: session,
      status: loading ? "loading" : session ? "authenticated" : "unauthenticated",
      update: async (data) => {
        if (loading || !session) {
          return;
        }
        setLoading(true);
        const updatedSession = await fetchData(
          "session",
          authConfig,
          logger,
          data ? { body: { csrfToken: await getCsrfToken(), data } } : void 0
        );
        setLoading(false);
        if (updatedSession) {
          setSession(updatedSession);
        }
        return updatedSession;
      }
    }),
    [session, loading, setSession]
  );
  return React.createElement(SessionContext.Provider, { value: contextValue }, children);
}
function useSession(options) {
  if (!SessionContext) {
    throw new Error("React Context is unavailable in Server Components");
  }
  const config = authConfigManager.getConfig();
  const session = (0, import_react.useContext)(SessionContext);
  const { required, onUnauthenticated } = options ?? {};
  const requiredAndNotLoading = required && (session == null ? void 0 : session.status) === "unauthenticated";
  (0, import_react.useEffect)(() => {
    if (requiredAndNotLoading) {
      const url = `${config.baseUrl}${config.basePath}/signin?${new URLSearchParams({
        error: "SessionRequired",
        callbackUrl: window.location.href
      })}`;
      if (onUnauthenticated) {
        onUnauthenticated();
      } else {
        window.location.href = url;
      }
    }
  }, [requiredAndNotLoading, onUnauthenticated]);
  if (requiredAndNotLoading) {
    return {
      data: session == null ? void 0 : session.data,
      update: session == null ? void 0 : session.update,
      status: "loading"
    };
  }
  return session;
}
async function getProviders() {
  return fetchData("providers", authConfigManager.getConfig(), logger);
}
async function signIn(provider, options = {}, authorizationParams = {}) {
  var _a2;
  const { callbackUrl = window.location.href, redirect = true, ...opts } = options;
  const config = authConfigManager.getConfig();
  const href = `${config.baseUrl}${config.basePath}`;
  const providers = await getProviders();
  if (!providers) {
    window.location.href = `${href}/error`;
    return;
  }
  if (!provider || !(provider in providers)) {
    window.location.href = `${href}/signin?${new URLSearchParams({ callbackUrl })}`;
    return;
  }
  const isCredentials = providers[provider].type === "credentials";
  const isEmail = providers[provider].type === "email";
  const signInUrl = `${href}/${isCredentials ? "callback" : "signin"}/${provider}`;
  const csrfToken = await getCsrfToken();
  const res = await fetch(`${signInUrl}?${new URLSearchParams(authorizationParams)}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "X-Auth-Return-Redirect": "1"
    },
    body: new URLSearchParams({ ...opts, csrfToken, callbackUrl }),
    credentials: config.credentials
  });
  const data = await res.json();
  if (redirect) {
    const url = data.url ?? callbackUrl;
    window.location.href = url;
    if (url.includes("#")) {
      window.location.reload();
    }
    return;
  }
  const error = new URL(data.url).searchParams.get("error");
  if (res.ok) {
    await ((_a2 = config.fetchSession) == null ? void 0 : _a2.call(config, { event: "storage" }));
  }
  return {
    error,
    status: res.status,
    ok: res.ok,
    url: error ? null : data.url
  };
}
async function signOut(options) {
  var _a2;
  const { callbackUrl = window.location.href, redirect = true } = options ?? {};
  const config = authConfigManager.getConfig();
  const csrfToken = await getCsrfToken();
  const res = await fetch(`${config.baseUrl}${config.basePath}/signout`, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "X-Auth-Return-Redirect": "1"
    },
    body: new URLSearchParams({ csrfToken, callbackUrl }),
    credentials: config.credentials
  });
  const data = await res.json();
  if (redirect) {
    const url = data.url ?? callbackUrl;
    window.location.href = url;
    if (url.includes("#")) {
      window.location.reload();
    }
    return void 0;
  }
  await ((_a2 = config.fetchSession) == null ? void 0 : _a2.call(config, { event: "storage" }));
  return data;
}
var createPopup = ({ url, title, height, width }) => {
  const left = window.screenX + (window.outerWidth - width) / 2;
  const top = window.screenY + (window.outerHeight - height) / 2.5;
  const externalPopup = window.open(
    url,
    title,
    `width=${width},height=${height},left=${left},top=${top}`
  );
  return externalPopup;
};
var useOauthPopupLogin = (provider, options = {}) => {
  const { width = 500, height = 500, title = "Signin", onSuccess, callbackUrl = "/" } = options;
  const [externalWindow, setExternalWindow] = (0, import_react.useState)();
  const [state, setState] = (0, import_react.useState)({ status: "loading" });
  const popUpSignin = (0, import_react.useCallback)(async () => {
    const res = await signIn(provider, {
      redirect: false,
      callbackUrl
    });
    if (res == null ? void 0 : res.error) {
      setState({ status: "errored", error: res.error });
      return;
    }
    setExternalWindow(
      createPopup({
        url: res == null ? void 0 : res.url,
        title,
        width,
        height
      })
    );
  }, []);
  (0, import_react.useEffect)(() => {
    const handleMessage = (event) => {
      if (event.origin !== window.location.origin) {
        return;
      }
      if (event.data.status) {
        setState(event.data);
        if (event.data.status === "success") {
          onSuccess == null ? void 0 : onSuccess();
        }
        externalWindow == null ? void 0 : externalWindow.close();
      }
    };
    window.addEventListener("message", handleMessage);
    return () => {
      window.removeEventListener("message", handleMessage);
      externalWindow == null ? void 0 : externalWindow.close();
    };
  }, [externalWindow]);
  return { popUpSignin, ...state };
};
export {
  SessionContext,
  SessionProvider,
  authConfigManager,
  getCsrfToken,
  getProviders,
  getSession,
  signIn,
  signOut,
  useOauthPopupLogin,
  useSession
};
//# sourceMappingURL=@auth_create_react.js.map
