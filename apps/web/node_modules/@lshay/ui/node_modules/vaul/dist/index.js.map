{"version":3,"sources":["../src/index.tsx","../src/use-controllable-state.ts","../src/context.ts","#style-inject:#style-inject","../src/style.css","../src/use-prevent-scroll.ts","../src/use-composed-refs.ts"],"sourcesContent":["'use client';\n\nimport * as DialogPrimitive from '@radix-ui/react-dialog';\nimport { useControllableState } from './use-controllable-state';\nimport { DrawerContext, useDrawerContext } from './context';\nimport React, { useEffect } from 'react';\nimport './style.css';\nimport { usePreventScroll, isInput } from './use-prevent-scroll';\nimport { useComposedRefs } from './use-composed-refs';\n\nconst CLOSE_THRESHOLD = 0.25;\n\nconst SCROLL_LOCK_TIMEOUT = 1000;\n\nconst TRANSITIONS = {\n  DURATION: 0.5,\n  EASE: [0.32, 0.72, 0, 1],\n};\n\nconst ANIMATION_DURATION = 501;\n\nconst BORDER_RADIUS = 8;\n\nconst cache = new Map();\n\ninterface Style {\n  [key: string]: string;\n}\n\nfunction isInView(el: HTMLElement): boolean {\n  const rect = el.getBoundingClientRect();\n\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    // Need + 40 for safari detection\n    rect.bottom <= window.visualViewport.height + 40 &&\n    rect.right <= window.visualViewport.width\n  );\n}\n\nfunction set(el?: Element | HTMLElement | null, styles?: Style, ignoreCache = false) {\n  if (!el || !(el instanceof HTMLElement) || !styles) return;\n  let originalStyles: Style = {};\n\n  Object.entries(styles).forEach(([key, value]: [string, string]) => {\n    if (key.startsWith('--')) {\n      el.style.setProperty(key, value);\n      return;\n    }\n\n    originalStyles[key] = (el.style as any)[key];\n    (el.style as any)[key] = value;\n  });\n\n  if (ignoreCache) return;\n  cache.set(el, originalStyles);\n}\n\nfunction reset(el: Element | HTMLElement | null, prop?: string) {\n  if (!el || !(el instanceof HTMLElement)) return;\n  let originalStyles = cache.get(el);\n\n  if (!originalStyles) {\n    (el.style as any) = {};\n    return;\n  }\n\n  if (prop) {\n    (el.style as any)[prop] = originalStyles[prop];\n  } else {\n    Object.entries(originalStyles).forEach(([key, value]) => {\n      (el.style as any)[key] = value;\n    });\n  }\n}\n\ninterface DialogProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  closeThreshold?: number;\n  onOpenChange?(open: boolean): void;\n  shouldScaleBackground?: boolean;\n  scrollLockTimeout?: number;\n  dismissible?: boolean;\n  onDrag?(event: React.PointerEvent<HTMLDivElement>, percentageDragged: number): void;\n  onRelease?(event: React.PointerEvent<HTMLDivElement>, open: boolean): void;\n}\n\nfunction Root({\n  open: openProp,\n  defaultOpen,\n  onOpenChange,\n  children,\n  shouldScaleBackground,\n  onDrag: onDragProp,\n  onRelease: onReleaseProp,\n  closeThreshold = CLOSE_THRESHOLD,\n  scrollLockTimeout = SCROLL_LOCK_TIMEOUT,\n  dismissible = true,\n}: DialogProps) {\n  const [isOpen = false, setIsOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [isDragging, setIsDragging] = React.useState(false);\n  const [isAnimating, setIsAnimating] = React.useState(true);\n  const overlayRef = React.useRef<HTMLDivElement>(null);\n  const dragStartTime = React.useRef<Date | null>(null);\n  const dragEndTime = React.useRef<Date | null>(null);\n  const lastTimeScrolled = React.useRef<Date | null>(null);\n  const nestedOpenChangeTimer = React.useRef<NodeJS.Timeout>(null);\n  const pointerStartY = React.useRef(0);\n  const keyboardIsOpen = React.useRef(false);\n  const drawerRef = React.useRef<HTMLDivElement>(null);\n  const initialViewportHeight = React.useRef(0);\n\n  usePreventScroll({\n    isDisabled: !isOpen || isDragging || isAnimating,\n  });\n\n  function getScale() {\n    return (window.innerWidth - 26) / window.innerWidth;\n  }\n\n  function onPress(event: React.PointerEvent<HTMLDivElement>) {\n    if (!dismissible) return;\n    if (!drawerRef.current.contains(event.target as Node) || (event.target as HTMLElement).tagName === 'BUTTON') return;\n\n    setIsDragging(true);\n    dragStartTime.current = new Date();\n\n    // Ensure we maintain correct pointer capture even when going outside of the drawer\n    (event.target as HTMLElement).setPointerCapture(event.pointerId);\n\n    pointerStartY.current = event.clientY;\n  }\n\n  function shouldDrag(el: EventTarget, isDraggingDown: boolean) {\n    let element = el as HTMLElement;\n    const date = new Date();\n    const highlightedText = window.getSelection().toString();\n\n    // Don't drag if there's highlighted text\n    if (highlightedText.length > 0) {\n      return false;\n    }\n\n    // Disallow dragging if drawer was scrolled within last second\n    if (lastTimeScrolled.current && date.getTime() - lastTimeScrolled.current.getTime() < scrollLockTimeout) {\n      return false;\n    }\n\n    // Keep climbing up the DOM tree as long as there's a parent\n    while (element) {\n      // Check if the element is scrollable\n      if (element.scrollHeight > element.clientHeight) {\n        if (element.role === 'dialog' || element.getAttribute('vaul-drawer')) return true;\n\n        if (element.scrollTop > 0) {\n          lastTimeScrolled.current = new Date();\n\n          // The element is scrollable and not scrolled to the top, so don't drag\n          return false;\n        }\n\n        if (isDraggingDown && element !== document.body) {\n          lastTimeScrolled.current = new Date();\n          // Element is scrolled to the top, but we are dragging down so we should allow scrolling\n          return false;\n        }\n      }\n\n      // Move up to the parent element\n      element = element.parentNode as HTMLElement;\n    }\n\n    // No scrollable parents not scrolled to the top found, so drag\n    return true;\n  }\n\n  function onDrag(event: React.PointerEvent<HTMLDivElement>) {\n    // We need to know how much of the drawer has been dragged in percentages so that we can transform background accordingly\n    if (isDragging) {\n      const draggedDistance = pointerStartY.current - event.clientY;\n      const isDraggingDown = draggedDistance > 0;\n\n      if (!shouldDrag(event.target, isDraggingDown)) return;\n\n      const drawerHeight = drawerRef.current?.getBoundingClientRect().height || 0;\n\n      set(drawerRef.current, {\n        transition: 'none',\n      });\n\n      set(overlayRef.current, {\n        transition: 'none',\n      });\n\n      // Allow dragging upwards up to 40px\n      if (draggedDistance > 0) {\n        set(drawerRef.current, {\n          '--swipe-amount': `${Math.max(draggedDistance * -1, -40)}px`,\n        });\n        return;\n      }\n\n      // We need to capture last time when drag with scroll was triggered and have a timeout between\n      const absDraggedDistance = Math.abs(draggedDistance);\n      const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n\n      const percentageDragged = absDraggedDistance / drawerHeight;\n      const opacityValue = 1 - percentageDragged;\n      onDragProp?.(event, percentageDragged);\n      set(\n        overlayRef.current,\n        {\n          opacity: `${opacityValue}`,\n        },\n        true,\n      );\n\n      if (wrapper && overlayRef.current && shouldScaleBackground) {\n        // Calculate percentageDragged as a fraction (0 to 1)\n        const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);\n        const borderRadiusValue = 8 - percentageDragged * 8;\n\n        const translateYValue = Math.max(0, 14 - percentageDragged * 14);\n\n        set(\n          wrapper,\n          {\n            borderRadius: `${borderRadiusValue}px`,\n            transform: `scale(${scaleValue}) translateY(${translateYValue}px)`,\n            transition: 'none',\n          },\n          true,\n        );\n      }\n\n      set(drawerRef.current, {\n        '--swipe-amount': `${absDraggedDistance}px`,\n      });\n    }\n  }\n\n  useEffect(() => {\n    initialViewportHeight.current = window.visualViewport.height;\n\n    function onVisualViewportChange() {\n      if (!drawerRef.current) return;\n      const focusedElement = document.activeElement as HTMLElement;\n\n      if ((!isInView(focusedElement) && isInput(focusedElement)) || keyboardIsOpen.current) {\n        const visualViewportHeight = window.visualViewport.height;\n        const diffFromInitial = initialViewportHeight.current - visualViewportHeight;\n        const drawerHeight = drawerRef.current?.getBoundingClientRect().height || 0;\n        const offsetFromTop = drawerRef.current?.getBoundingClientRect().top;\n        keyboardIsOpen.current = !keyboardIsOpen.current;\n        // We don't have to change the height if the input is in view, when we are here we are in the opened keyboard state so we can accuretly check if the input is in view\n        if (drawerHeight > visualViewportHeight) {\n          drawerRef.current.style.height = `${visualViewportHeight - offsetFromTop}px`;\n        } else {\n          drawerRef.current.style.height = 'initial';\n        }\n\n        drawerRef.current.style.bottom = `${diffFromInitial}px`;\n      }\n    }\n\n    window.visualViewport.addEventListener('resize', onVisualViewportChange);\n    return () => window.visualViewport.removeEventListener('resize', onVisualViewportChange);\n  }, []);\n\n  function closeDrawer() {\n    if (!dismissible) return;\n    setIsOpen(false);\n    const drawerHeight = drawerRef.current?.getBoundingClientRect().height || 0;\n\n    if (drawerRef.current) {\n      const swipeAmount = getComputedStyle(drawerRef.current).getPropertyValue('--swipe-amount').slice(0, -2);\n\n      set(drawerRef.current, {\n        '--hide-from': `${Number(swipeAmount).toFixed()}px`,\n        '--hide-to': `${drawerHeight.toFixed()}px`,\n      });\n\n      const opacityValue = overlayRef.current?.style.opacity || 1;\n\n      set(overlayRef.current, {\n        '--opacity-from': `${opacityValue}`,\n      });\n    }\n  }\n\n  React.useEffect(() => {\n    if (!isOpen && shouldScaleBackground) {\n      // Can't use `onAnimationEnd` as the component will be unmounted by then\n      const id = setTimeout(() => {\n        reset(document.body);\n      }, 200);\n\n      return () => clearTimeout(id);\n    }\n  }, [isOpen]);\n\n  function resetDrawer() {\n    const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n    const currentSwipeAmount = Number(\n      getComputedStyle(drawerRef.current).getPropertyValue('--swipe-amount').slice(0, -2),\n    );\n\n    set(drawerRef.current, {\n      '--swipe-amount': `${0}px`,\n      transition: `transform 500ms cubic-bezier(0.32, 0.72, 0, 1)`,\n    });\n\n    set(overlayRef.current, {\n      transition: `opacity ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n      opacity: '1',\n    });\n\n    // Don't reset background if swiped upwards\n    if (shouldScaleBackground && currentSwipeAmount > 0 && isOpen) {\n      set(\n        wrapper,\n        {\n          borderRadius: `${BORDER_RADIUS}px`,\n          overflow: 'hidden',\n          transform: `scale(${getScale()}) translateY(calc(env(safe-area-inset-top) + 14px))`,\n          transformOrigin: 'top',\n          transitionProperty: 'transform, border-radius',\n          transitionDuration: `${TRANSITIONS.DURATION}s`,\n          transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n        },\n        true,\n      );\n    }\n  }\n\n  function onRelease(event: React.PointerEvent<HTMLDivElement>) {\n    if ((event.target as HTMLElement).tagName === 'BUTTON' || !isDragging) return;\n    setIsDragging(false);\n    dragEndTime.current = new Date();\n    const swipeAmount = drawerRef.current\n      ? Number.parseInt(getComputedStyle(drawerRef.current).getPropertyValue('--swipe-amount').slice(0, -2), 10)\n      : null;\n\n    if (!shouldDrag(event.target, false) || !swipeAmount || Number.isNaN(swipeAmount)) return;\n\n    if (dragStartTime.current === null) return;\n\n    const y = event.clientY;\n\n    const timeTaken = dragEndTime.current.getTime() - dragStartTime.current.getTime();\n    const distMoved = pointerStartY.current - y;\n    const velocity = Math.abs(distMoved) / timeTaken;\n\n    // Moved upwards, don't do anything\n    if (distMoved > 0) {\n      resetDrawer();\n      onReleaseProp?.(event, false);\n      return;\n    }\n\n    if (velocity > 0.4) {\n      closeDrawer();\n      onReleaseProp?.(event, false);\n      return;\n    }\n\n    const visibleDrawerHeight = Math.min(drawerRef.current?.getBoundingClientRect().height || 0, window.innerHeight);\n\n    if (swipeAmount >= visibleDrawerHeight * closeThreshold) {\n      closeDrawer();\n      onReleaseProp?.(event, false);\n      return;\n    }\n\n    onReleaseProp?.(event, true);\n    resetDrawer();\n  }\n\n  function onAnimationStart(e: React.AnimationEvent<HTMLDivElement>) {\n    const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n\n    if (!wrapper || !shouldScaleBackground) return;\n\n    if (e.animationName === 'show-dialog') {\n      set(\n        document.body,\n        {\n          background: 'black',\n        },\n        true,\n      );\n\n      set(wrapper, {\n        borderRadius: `${BORDER_RADIUS}px`,\n        overflow: 'hidden',\n        transform: `scale(${getScale()}) translateY(calc(env(safe-area-inset-top) + 14px))`,\n        transformOrigin: 'top',\n        transitionProperty: 'transform, border-radius',\n        transitionDuration: `${TRANSITIONS.DURATION}s`,\n        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n      });\n    } else if (e.animationName === 'hide-dialog') {\n      // Exit\n      reset(wrapper, 'transform');\n      reset(wrapper, 'borderRadius');\n      set(wrapper, {\n        transitionProperty: 'transform, border-radius',\n        transitionDuration: `${TRANSITIONS.DURATION}s`,\n        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n      });\n    }\n  }\n\n  function onNestedOpenChange(o: boolean) {\n    const scale = o ? (window.innerWidth - 16) / window.innerWidth : 1;\n    const y = o ? -16 : 0;\n    window.clearTimeout(nestedOpenChangeTimer.current);\n\n    set(drawerRef.current, {\n      transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n      transform: `scale(${scale}) translateY(${y}px)`,\n    });\n\n    if (!o) {\n      nestedOpenChangeTimer.current = setTimeout(() => {\n        set(drawerRef.current, {\n          transition: 'none',\n          transform: 'translateY(var(--swipe-amount))',\n        });\n      }, 500);\n    }\n  }\n\n  function onNestedDrag(event: React.PointerEvent<HTMLDivElement>, percentageDragged: number) {\n    if (percentageDragged < 0) return;\n    const initialScale = (window.innerWidth - 16) / window.innerWidth;\n    const newScale = initialScale + percentageDragged * (1 - initialScale);\n    const newY = -16 + percentageDragged * 16;\n\n    set(drawerRef.current, {\n      transform: `scale(${newScale}) translateY(${newY}px)`,\n      transition: 'none',\n    });\n  }\n\n  function onNestedRelease(event: React.PointerEvent<HTMLDivElement>, o: boolean) {\n    const scale = o ? (window.innerWidth - 16) / window.innerWidth : 1;\n    const y = o ? -16 : 0;\n\n    if (o) {\n      set(drawerRef.current, {\n        transition: `transform ${TRANSITIONS.DURATION}s cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n        transform: `scale(${scale}) translateY(${y}px)`,\n      });\n    }\n  }\n\n  return (\n    <DialogPrimitive.Root\n      open={isOpen}\n      onOpenChange={(o) => {\n        setIsOpen(o);\n      }}\n    >\n      <DrawerContext.Provider\n        value={{\n          drawerRef,\n          overlayRef,\n          onAnimationStart,\n          onPress,\n          onRelease,\n          onDrag,\n          dismissible,\n          isOpen,\n          onNestedDrag,\n          onNestedOpenChange,\n          onNestedRelease,\n          keyboardIsOpen,\n          setIsAnimating,\n        }}\n      >\n        {children}\n      </DrawerContext.Provider>\n    </DialogPrimitive.Root>\n  );\n}\n\nconst Overlay = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>>(\n  function ({ children, ...rest }, ref) {\n    const { overlayRef, onRelease } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, overlayRef);\n\n    return <DialogPrimitive.Overlay onMouseUp={onRelease} ref={composedRef} vaul-overlay=\"\" {...rest} />;\n  },\n);\n\ntype ContentProps = React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> & {\n  onAnimationEnd?: (open: boolean) => void;\n};\n\nconst Content = React.forwardRef<HTMLDivElement, ContentProps>(function (\n  { children, onOpenAutoFocus, onPointerDownOutside, onAnimationEnd, ...rest },\n  ref,\n) {\n  const {\n    drawerRef,\n    onPress,\n    onRelease,\n    onAnimationStart,\n    onDrag,\n    dismissible,\n    isOpen,\n    keyboardIsOpen,\n    setIsAnimating,\n  } = useDrawerContext();\n  const composedRef = useComposedRefs(ref, drawerRef);\n  const animationEndTimer = React.useRef<NodeJS.Timeout>(null);\n\n  return (\n    <DialogPrimitive.Content\n      onAnimationStart={(e) => {\n        window.clearTimeout(animationEndTimer.current);\n        setIsAnimating(true);\n\n        animationEndTimer.current = setTimeout(() => {\n          setIsAnimating(false);\n          onAnimationEnd?.(isOpen);\n        }, ANIMATION_DURATION);\n        onAnimationStart(e);\n      }}\n      onPointerDown={onPress}\n      onPointerUp={onRelease}\n      onPointerMove={onDrag}\n      onOpenAutoFocus={(e) => {\n        if (onOpenAutoFocus) {\n          onOpenAutoFocus(e);\n        } else {\n          e.preventDefault();\n        }\n      }}\n      onPointerDownOutside={(e) => {\n        if (keyboardIsOpen.current) {\n          keyboardIsOpen.current = false;\n          set(drawerRef.current, {\n            '--hide-to': `200%`,\n          });\n        }\n        if (!dismissible) {\n          e.preventDefault();\n        }\n        onPointerDownOutside?.(e);\n      }}\n      ref={composedRef}\n      {...rest}\n      vaul-drawer=\"\"\n    >\n      {children}\n    </DialogPrimitive.Content>\n  );\n});\n\nfunction NestedRoot({ children, onDrag, onOpenChange }: DialogProps) {\n  const { onNestedDrag, onNestedOpenChange, onNestedRelease } = useDrawerContext();\n\n  if (!onNestedDrag) {\n    throw new Error('Drawer.NestedRoot must be placed in another drawer');\n  }\n\n  return (\n    <Root\n      onDrag={(e, p) => {\n        onNestedDrag(e, p);\n        onDrag?.(e, p);\n      }}\n      onOpenChange={(o) => {\n        onNestedOpenChange(o);\n        onOpenChange?.(o);\n      }}\n      onRelease={onNestedRelease}\n    >\n      {children}\n    </Root>\n  );\n}\n\nexport const Drawer = Object.assign(\n  {},\n  {\n    Root,\n    NestedRoot,\n    Content,\n    Overlay,\n    Trigger: DialogPrimitive.Trigger,\n    Portal: DialogPrimitive.Portal,\n    Close: DialogPrimitive.Close,\n    Title: DialogPrimitive.Title,\n    Description: DialogPrimitive.Description,\n  },\n);\n","// This code comes from https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\n\nimport React from 'react';\n\ntype UseControllableStateParams<T> = {\n  prop?: T | undefined;\n  defaultProp?: T | undefined;\n  onChange?: (state: T) => void;\n};\n\ntype SetStateFn<T> = (prevState?: T) => T;\n\nfunction useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\n}\n\nfunction useUncontrolledState<T>({ defaultProp, onChange }: Omit<UseControllableStateParams<T>, 'prop'>) {\n  const uncontrolledState = React.useState<T | undefined>(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = React.useRef(value);\n  const handleChange = useCallbackRef(onChange);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value as T);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef, handleChange]);\n\n  return uncontrolledState;\n}\nexport function useControllableState<T>({ prop, defaultProp, onChange = () => {} }: UseControllableStateParams<T>) {\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n  const handleChange = useCallbackRef(onChange);\n\n  const setValue: React.Dispatch<React.SetStateAction<T | undefined>> = React.useCallback(\n    (nextValue) => {\n      if (isControlled) {\n        const setter = nextValue as SetStateFn<T>;\n        const value = typeof nextValue === 'function' ? setter(prop) : nextValue;\n        if (value !== prop) handleChange(value as T);\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, handleChange],\n  );\n\n  return [value, setValue] as const;\n}\n","import React from 'react';\n\ninterface DrawerContextValue {\n  drawerRef: React.RefObject<HTMLDivElement>;\n  overlayRef: React.RefObject<HTMLDivElement>;\n  onAnimationStart: (event: React.AnimationEvent<HTMLDivElement>) => void;\n  onPress: (event: React.PointerEvent<HTMLDivElement>) => void;\n  onRelease: (event: React.PointerEvent<HTMLDivElement>) => void;\n  onDrag: (event: React.PointerEvent<HTMLDivElement>) => void;\n  onNestedDrag: (event: React.PointerEvent<HTMLDivElement>, percentageDragged: number) => void;\n  onNestedOpenChange: (o: boolean) => void;\n  onNestedRelease: (event: React.PointerEvent<HTMLDivElement>, open: boolean) => void;\n  dismissible: boolean;\n  isOpen: boolean;\n  setIsAnimating: (o: boolean) => void;\n  keyboardIsOpen: React.MutableRefObject<boolean>;\n}\n\nexport const DrawerContext = React.createContext<DrawerContextValue | undefined>(undefined);\n\nexport const useDrawerContext = () => React.useContext(DrawerContext);\n","\n          export default function styleInject(css, { insertAt } = {}) {\n            if (!css || typeof document === 'undefined') return\n          \n            const head = document.head || document.getElementsByTagName('head')[0]\n            const style = document.createElement('style')\n            style.type = 'text/css'\n          \n            if (insertAt === 'top') {\n              if (head.firstChild) {\n                head.insertBefore(style, head.firstChild)\n              } else {\n                head.appendChild(style)\n              }\n            } else {\n              head.appendChild(style)\n            }\n          \n            if (style.styleSheet) {\n              style.styleSheet.cssText = css\n            } else {\n              style.appendChild(document.createTextNode(css))\n            }\n          }\n          ","import styleInject from '#style-inject';styleInject(\"[vaul-drawer]{transform:translateY(var(--swipe-amount));touch-action:none;animation:show-dialog .5s cubic-bezier(.32,.72,0,1)}[vaul-drawer]:after{content:\\\"\\\";position:absolute;top:100%;background:inherit;background-color:inherit;left:0;right:0;height:200%}[vaul-drawer][data-state=closed]{animation:hide-dialog .5s cubic-bezier(.32,.72,0,1) forwards}[vaul-overlay]{animation:show-overlay .5s cubic-bezier(.32,.72,0,1)}[vaul-overlay][data-state=closed]{animation:hide-overlay .5s cubic-bezier(.32,.72,0,1) forwards}@keyframes show-dialog{0%{transform:translateY(100%)}to{transform:translateY(0)}}@keyframes hide-dialog{0%{transform:translateY(var(--hide-from, 0))}to{transform:translateY(var(--hide-to, 100%))}}@keyframes show-overlay{0%{opacity:0}to{opacity:1}}@keyframes hide-overlay{0%{opacity:var(--opacity-from, 1)}to{opacity:0}}@media (hover: hover) and (pointer: fine){[vaul-drawer]{user-select:none}}\\n\")","// This code comes from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/overlays/src/usePreventScroll.ts\n\nimport { useEffect, useLayoutEffect } from 'react';\n\nexport const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\ninterface PreventScrollOptions {\n  /** Whether the scroll lock is disabled. */\n  isDisabled?: boolean;\n  focusCallback?: () => void;\n}\n\nfunction chain(...callbacks: any[]): (...args: any[]) => void {\n  return (...args: any[]) => {\n    for (let callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\n\nfunction isMac(): boolean | undefined {\n  return testPlatform(/^Mac/);\n}\n\nfunction isIPhone(): boolean | undefined {\n  return testPlatform(/^iPhone/);\n}\n\nfunction isIPad(): boolean | undefined {\n  return (\n    testPlatform(/^iPad/) ||\n    // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    (isMac() && navigator.maxTouchPoints > 1)\n  );\n}\n\nfunction isIOS(): boolean | undefined {\n  return isIPhone() || isIPad();\n}\n\nfunction testPlatform(re: RegExp): boolean | undefined {\n  return typeof window !== 'undefined' && window.navigator != null ? re.test(window.navigator.platform) : undefined;\n}\n\n// @ts-ignore\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\nexport function isScrollable(node: Element): boolean {\n  let style = window.getComputedStyle(node);\n  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\n\nexport function getScrollParent(node: Element): Element {\n  if (isScrollable(node)) {\n    node = node.parentElement as HTMLElement;\n  }\n\n  while (node && !isScrollable(node)) {\n    node = node.parentElement as HTMLElement;\n  }\n\n  return node || document.scrollingElement || document.documentElement;\n}\n\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset',\n]);\n\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(options: PreventScrollOptions = {}) {\n  let { isDisabled } = options;\n\n  useIsomorphicLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore();\n      }\n    };\n  }, [isDisabled]);\n}\n\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  return chain(\n    setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`),\n    setStyle(document.documentElement, 'overflow', 'hidden'),\n  );\n}\n\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n  let scrollable: Element;\n  let lastY = 0;\n  let onTouchStart = (e: TouchEvent) => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = getScrollParent(e.target as Element);\n    if (scrollable === document.documentElement && scrollable === document.body) {\n      return;\n    }\n\n    lastY = e.changedTouches[0].pageY;\n  };\n\n  let onTouchMove = (e: TouchEvent) => {\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead. Unfortunately, this disables bounce scrolling when at\n    // the top but it's the best we can do.\n    let y = e.changedTouches[0].pageY;\n    let scrollTop = scrollable.scrollTop;\n    let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n\n    if (bottom === 0) {\n      return;\n    }\n\n    if ((scrollTop <= 0 && y > lastY) || (scrollTop >= bottom && y < lastY)) {\n      e.preventDefault();\n    }\n\n    lastY = y;\n  };\n\n  let onTouchEnd = (e: TouchEvent) => {\n    let target = e.target as HTMLElement;\n\n    // Apply this change if we're not already focused on the target element\n    if (isInput(target) && target !== document.activeElement) {\n      e.preventDefault();\n\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n      // be done before the \"focus\" event, so we have to focus the element ourselves.\n      target.style.transform = 'translateY(-2000px)';\n      target.focus();\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n      });\n    }\n  };\n\n  let onFocus = (e: FocusEvent) => {\n    let target = e.target as HTMLElement;\n    if (isInput(target)) {\n      // Transform also needs to be applied in the focus event in cases where focus moves\n      // other than tapping on an input directly, e.g. the next/previous buttons in the\n      // software keyboard. In these cases, it seems applying the transform in the focus event\n      // is good enough, whereas when tapping an input, it must be done before the focus event. ðŸ¤·â€â™‚ï¸\n      target.style.transform = 'translateY(-2000px)';\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if (visualViewport) {\n          if (visualViewport.height < window.innerHeight) {\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              scrollIntoView(target);\n            });\n          } else {\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            visualViewport.addEventListener('resize', () => scrollIntoView(target), { once: true });\n          }\n        }\n      });\n    }\n  };\n\n  let onWindowScroll = () => {\n    // Last resort. If the window scrolled, scroll it back to the top.\n    // It should always be at the top because the body will have a negative margin (see below).\n    window.scrollTo(0, 0);\n  };\n\n  // Record the original scroll position so we can restore it.\n  // Then apply a negative margin to the body to offset it by the scroll position. This will\n  // enable us to scroll the window to the top, which is required for the rest of this to work.\n  let scrollX = window.pageXOffset;\n  let scrollY = window.pageYOffset;\n\n  let restoreStyles = chain(\n    setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`),\n    setStyle(document.documentElement, 'overflow', 'hidden'),\n    setStyle(document.body, 'marginTop', `-${scrollY}px`),\n  );\n\n  // Scroll to the top. The negative margin on the body will make this appear the same.\n  window.scrollTo(0, 0);\n\n  let removeEvents = chain(\n    addEvent(document, 'touchstart', onTouchStart, { passive: false, capture: true }),\n    addEvent(document, 'touchmove', onTouchMove, { passive: false, capture: true }),\n    addEvent(document, 'touchend', onTouchEnd, { passive: false, capture: true }),\n    addEvent(document, 'focus', onFocus, true),\n    addEvent(window, 'scroll', onWindowScroll),\n  );\n\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreStyles();\n    removeEvents();\n    window.scrollTo(scrollX, scrollY);\n  };\n}\n\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element: HTMLElement, style: string, value: string) {\n  let cur = element.style[style];\n  element.style[style] = value;\n\n  return () => {\n    element.style[style] = cur;\n  };\n}\n\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent<K extends keyof GlobalEventHandlersEventMap>(\n  target: EventTarget,\n  event: K,\n  handler: (this: Document, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions,\n) {\n  // @ts-ignore\n  target.addEventListener(event, handler, options);\n\n  return () => {\n    // @ts-ignore\n    target.removeEventListener(event, handler, options);\n  };\n}\n\nfunction scrollIntoView(target: Element) {\n  let root = document.scrollingElement || document.documentElement;\n  while (target && target !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = getScrollParent(target);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n      let scrollableTop = scrollable.getBoundingClientRect().top;\n      let targetTop = target.getBoundingClientRect().top;\n      const keyboardHeight = scrollable.getBoundingClientRect().bottom;\n\n      if (targetTop > keyboardHeight) {\n        scrollable.scrollTop += targetTop - scrollableTop;\n      }\n    }\n\n    // @ts-ignore\n    target = scrollable.parentElement;\n  }\n}\n\nexport function isInput(target: Element) {\n  return (\n    (target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type)) ||\n    target instanceof HTMLTextAreaElement ||\n    (target instanceof HTMLElement && target.isContentEditable)\n  );\n}\n","// This code comes from https://github.com/radix-ui/primitives/tree/main/packages/react/compose-refs\n\nimport * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    (ref as React.MutableRefObject<T>).current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]) {\n  return (node: T) => refs.forEach((ref) => setRef(ref, node));\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n"],"mappings":"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","names":["src_exports","__export","Drawer","__toCommonJS","DialogPrimitive","import_react","useCallbackRef","callback","callbackRef","React","args","_a","useUncontrolledState","defaultProp","onChange","uncontrolledState","value","prevValueRef","handleChange","useControllableState","prop","uncontrolledProp","setUncontrolledProp","isControlled","setValue","nextValue","import_react","DrawerContext","React","useDrawerContext","import_react","styleInject","css","insertAt","head","style","styleInject","import_react","useIsomorphicLayoutEffect","chain","callbacks","args","callback","isMac","testPlatform","isIPhone","isIPad","isIOS","re","visualViewport","isScrollable","node","style","getScrollParent","nonTextInputTypes","preventScrollCount","restore","usePreventScroll","options","isDisabled","preventScrollMobileSafari","preventScrollStandard","setStyle","scrollable","lastY","onTouchStart","e","onTouchMove","y","scrollTop","bottom","onTouchEnd","target","isInput","onFocus","scrollIntoView","onWindowScroll","scrollX","scrollY","restoreStyles","removeEvents","addEvent","element","value","cur","event","handler","root","scrollableTop","targetTop","keyboardHeight","React","setRef","ref","value","composeRefs","refs","node","useComposedRefs","CLOSE_THRESHOLD","SCROLL_LOCK_TIMEOUT","TRANSITIONS","ANIMATION_DURATION","BORDER_RADIUS","cache","isInView","el","rect","set","styles","ignoreCache","originalStyles","key","value","reset","prop","Root","openProp","defaultOpen","onOpenChange","children","shouldScaleBackground","onDragProp","onReleaseProp","closeThreshold","scrollLockTimeout","dismissible","isOpen","setIsOpen","useControllableState","isDragging","setIsDragging","React","isAnimating","setIsAnimating","overlayRef","dragStartTime","dragEndTime","lastTimeScrolled","nestedOpenChangeTimer","pointerStartY","keyboardIsOpen","drawerRef","initialViewportHeight","usePreventScroll","getScale","onPress","event","shouldDrag","isDraggingDown","element","date","onDrag","_a","draggedDistance","drawerHeight","absDraggedDistance","wrapper","percentageDragged","opacityValue","scaleValue","borderRadiusValue","translateYValue","onVisualViewportChange","_b","focusedElement","isInput","visualViewportHeight","diffFromInitial","offsetFromTop","closeDrawer","swipeAmount","id","resetDrawer","currentSwipeAmount","onRelease","y","timeTaken","distMoved","velocity","visibleDrawerHeight","onAnimationStart","e","onNestedOpenChange","o","scale","onNestedDrag","initialScale","newScale","newY","onNestedRelease","DrawerContext","Overlay","rest","ref","useDrawerContext","composedRef","useComposedRefs","Content","onOpenAutoFocus","onPointerDownOutside","onAnimationEnd","animationEndTimer","NestedRoot","p","Drawer"]}